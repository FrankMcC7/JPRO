Option Explicit

' ===== Post-Remediation QC that uses your frmCoperBatches batching flow =====
Public Sub Run_PostRectification_QC_UsingForm()
    On Error GoTo Fail

    Dim iterPath As String
    Dim wbIter As Workbook, wsSum As Worksheet
    Dim targetMap As Object        ' coper -> Approved CoR
    Dim targetList() As String     ' unique copers for batching
    Dim batchSize As Long: batchSize = 600

    ' 1) Pick Iteration workbook
    iterPath = PQC_PickFile("Select the Iteration workbook (Iteration_MMM-YYYY.xlsx)", "Excel Files (*.xlsx)", "*.xlsx")
    If Len(iterPath) = 0 Then Exit Sub

    Set wbIter = Workbooks.Open(Filename:=iterPath, ReadOnly:=False)
    If Not SheetExists(wbIter, "CoR Mismatch Summary") Then
        MsgBox "'CoR Mismatch Summary' not found in the selected iteration file.", vbCritical
        GoTo Cleanup
    End If
    Set wsSum = wbIter.Worksheets("CoR Mismatch Summary")

    ' 2) Build targets (coper -> Approved CoR) and list for batching
    Set targetMap = CreateObject("Scripting.Dictionary")
    PQC_ParseMismatchSummaryToTargets wsSum, targetMap, targetList
    If targetMap.Count = 0 Then
        MsgBox "No copers found in 'CoR Mismatch Summary'. Nothing to QC.", vbInformation
        GoTo Cleanup
    End If

    ' 3) Use YOUR batching form: fill globals and show form
    PQC_FillBatchGlobals targetList, batchSize         ' sets G_Batches, G_BatchIndex, G_BatchCount
    G_WorkflowReadyToContinue = False
    frmCoperBatches.Show vbModeless

    MsgBox "Batches prepared. Paste each batch into Credit Studio and export the updated data." & vbCrLf & _
           "When done exporting, click 'Move On' on the form to continue.", vbInformation

    ' Wait until your form toggles the flag
    Do While Not G_WorkflowReadyToContinue
        DoEvents
        Application.Wait Now + TimeSerial(0, 0, 1)
    Loop

    ' 4) Pick UPDATED Credit Studio XLSX file(s)
    Dim creditFiles As Collection, p As Variant
    Dim wbCredit As Workbook, loCredit As ListObject
    Set creditFiles = PickFilesMulti("Select the UPDATED Credit Studio XLSX file(s) after rectification", "Excel Files (*.xlsx)", "*.xlsx")
    If creditFiles Is Nothing Or creditFiles.Count = 0 Then
        MsgBox "No updated Credit Studio files selected. Stopping.", vbInformation
        GoTo Cleanup
    End If

    ' 5) Build updated credit map (coper -> Credit CoR) from selected files
    Dim creditUpdated As Object: Set creditUpdated = CreateObject("Scripting.Dictionary")
    For Each p In creditFiles
        Set wbCredit = Workbooks.Open(Filename:=CStr(p), ReadOnly:=True)
        Set loCredit = EnsureTable(wbCredit.Worksheets(1), "CreditTbl")
        ' Reuse your existing helper; if you renamed it, swap the call accordingly:
        '   AppendCreditToDict loCredit, creditUpdated, "Coper ID", "Country of Risk"
        AppendCreditToDict loCredit, creditUpdated, "Coper ID", "Country of Risk"
        wbCredit.Close SaveChanges:=False
    Next p

    ' 6) Write Post-Remediation QC section in Iteration:Stats
    PQC_WritePostRemediationStats wbIter, targetMap, creditUpdated

    wbIter.Save
    MsgBox "Post-Remediation QC complete. Stats updated in the Iteration file.", vbInformation

Cleanup:
    On Error Resume Next
    If Not wbIter Is Nothing Then wbIter.Close SaveChanges:=True
    On Error GoTo 0
    Exit Sub

Fail:
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical
    Resume Cleanup
End Sub

' ---------- Parse mismatch summary into dict + list ----------
Private Sub PQC_ParseMismatchSummaryToTargets(ByVal ws As Worksheet, ByRef outMap As Object, ByRef outList() As String)
    Dim colCoR As Long, colCopers As Long
    colCoR = FindHeader(ws, "Country of Risk (AllFund, post-Keys normalization)")
    colCopers = FindHeader(ws, "Coper IDs with wrong CoR in Credit Studio (comma-joined)")

    ' fallback if headers were edited
    If colCoR = 0 Then colCoR = FindHeader(ws, "Country of Risk")
    If colCopers = 0 Then colCopers = FindHeader(ws, "Coper IDs")

    If colCoR = 0 Or colCopers = 0 Then Err.Raise vbObjectError + 4501, , "CoR Mismatch Summary: columns not found."

    Dim lastRow As Long: lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    Dim r As Long, aCoR As String, listStr As String, arr() As String, i As Long
    Dim uniq As Object: Set uniq = CreateObject("Scripting.Dictionary")

    For r = 2 To lastRow
        aCoR = Trim$(CStr(ws.Cells(r, colCoR).Value))
        listStr = Trim$(CStr(ws.Cells(r, colCopers).Value))
        If Len(aCoR) > 0 And Len(listStr) > 0 Then
            arr = Split(listStr, ",")
            For i = LBound(arr) To UBound(arr)
                Dim cid As String
                cid = SanitizeCoperID(arr(i))
                If Len(cid) > 0 Then
                    outMap(cid) = aCoR
                    If Not uniq.Exists(cid) Then uniq.Add cid, True
                End If
            Next i
        End If
    Next r

    If uniq.Count > 0 Then
        ReDim outList(1 To uniq.Count)
        Dim k As Variant, n As Long: n = 0
        For Each k In uniq.Keys
            n = n + 1
            outList(n) = CStr(k)
        Next k
    Else
        Erase outList
    End If
End Sub

' ---------- Fill your global batching variables for frmCoperBatches ----------
Private Sub PQC_FillBatchGlobals(ByRef ids() As String, ByVal batchSize As Long)
    Dim total As Long, batches As Long, b As Long, sIdx As Long, eIdx As Long

    If Not PQC_IsArrayAllocated(ids) Then Err.Raise vbObjectError + 4502, , "No coper IDs to batch."

    total = UBound(ids) - LBound(ids) + 1
    batches = (total \ batchSize) + IIf(total Mod batchSize = 0, 0, 1)

    ReDim G_Batches(1 To batches)
    For b = 1 To batches
        sIdx = (b - 1) * batchSize + 1
        eIdx = WorksheetFunction.Min(b * batchSize, total)
        G_Batches(b) = PQC_JoinRange(ids, sIdx, eIdx, ",")
    Next b

    G_BatchIndex = 1
    G_BatchCount = batches
End Sub

Private Function PQC_IsArrayAllocated(ByRef arr() As String) As Boolean
    On Error GoTo EH
    Dim lb As Long, ub As Long
    lb = LBound(arr): ub = UBound(arr)
    PQC_IsArrayAllocated = (ub >= lb)
    Exit Function
EH:
    PQC_IsArrayAllocated = False
End Function

Private Function PQC_JoinRange(ByRef arr() As String, ByVal startIdx As Long, ByVal endIdx As Long, ByVal delim As String) As String
    Dim i As Long, s As String
    For i = startIdx To endIdx
        If Len(s) > 0 Then s = s & delim
        s = s & arr(i)
    Next i
    PQC_JoinRange = s
End Function

' ---------- Write Post-Remediation QC into Stats ----------
Private Sub PQC_WritePostRemediationStats(ByVal iterWb As Workbook, _
                                          ByVal targetMap As Object, _
                                          ByVal creditUpdated As Object)

    Dim ws As Worksheet
    If SheetExists(iterWb, "Stats") Then
        Set ws = iterWb.Worksheets("Stats")
    Else
        Set ws = iterWb.Worksheets.Add(After:=iterWb.Sheets(iterWb.Sheets.Count))
        ws.Name = "Stats"
    End If

    Dim row As Long
    row = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    If row < 1 Then row = 1 Else row = row + 2

    With ws.Cells(row, 1)
        .Value = "Post-Remediation QC"
        .Font.Bold = True
        .Font.Size = 14
    End With
    row = row + 1

    Dim totalTarget As Long, foundInCredit As Long, rectified As Long, stillMismatch As Long, notFound As Long
    Dim k As Variant, expected As String, got As String

    totalTarget = targetMap.Count

    For Each k In targetMap.Keys
        expected = Trim$(CStr(targetMap(k)))
        If creditUpdated.Exists(k) Then
            foundInCredit = foundInCredit + 1
            got = Trim$(CStr(creditUpdated(k)))
            If StrComp(expected, got, vbTextCompare) = 0 Then
                rectified = rectified + 1
            Else
                stillMismatch = stillMismatch + 1
            End If
        Else
            notFound = notFound + 1
        End If
    Next k

    ws.Cells(row, 1).Value = "Metric"
    ws.Cells(row, 2).Value = "Count"
    ws.Cells(row, 3).Value = "% of Target"
    ws.Range(ws.Cells(row, 1), ws.Cells(row, 3)).Font.Bold = True
    row = row + 1

    Dim startTbl As Long: startTbl = row
    ws.Cells(row, 1).Value = "Target Copers (from CoR Mismatch Summary)": ws.Cells(row, 2).Value = totalTarget: ws.Cells(row, 3).Value = PQC_SafePercent(totalTarget, totalTarget): row = row + 1
    ws.Cells(row, 1).Value = "Found in Updated Credit":                   ws.Cells(row, 2).Value = foundInCredit: ws.Cells(row, 3).Value = PQC_SafePercent(foundInCredit, totalTarget): row = row + 1
    ws.Cells(row, 1).Value = "Rectified (Credit CoR now matches Approved)": ws.Cells(row, 2).Value = rectified: ws.Cells(row, 3).Value = PQC_SafePercent(rectified, totalTarget): row = row + 1
    ws.Cells(row, 1).Value = "Still Mismatched":                           ws.Cells(row, 2).Value = stillMismatch: ws.Cells(row, 3).Value = PQC_SafePercent(stillMismatch, totalTarget): row = row + 1
    ws.Cells(row, 1).Value = "Not Found in Updated Credit":                ws.Cells(row, 2).Value = notFound: ws.Cells(row, 3).Value = PQC_SafePercent(notFound, totalTarget): row = row + 1

    Dim lo As ListObject
    Set lo = ws.ListObjects.Add(xlSrcRange, ws.Range(ws.Cells(startTbl - 1, 1), ws.Cells(row - 1, 3)), , xlYes)
    On Error Resume Next
    lo.Name = "PostRemediationQCTbl"
    lo.TableStyle = "TableStyleMedium9"
    On Error GoTo 0
    ws.Range(ws.Cells(startTbl, 3), ws.Cells(row - 1, 3)).NumberFormat = "0.0%"
    ws.Columns.AutoFit
End Sub

' ---------- Tiny utilities (isolated to avoid collisions) ----------
Private Function PQC_PickFile(ByVal promptTitle As String, ByVal filterDesc As String, ByVal filterPattern As String) As String
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = promptTitle
        .Filters.Clear
        .Filters.Add filterDesc, filterPattern
        .AllowMultiSelect = False
        If .Show = -1 Then PQC_PickFile = .SelectedItems(1)
    End With
End Function

Private Function PQC_SafePercent(ByVal num As Long, ByVal den As Long) As Double
    If den <= 0 Then PQC_SafePercent = 0 Else PQC_SafePercent = num / den
End Function

Private Function SheetExists(ByVal wb As Workbook, ByVal name As String) As Boolean
    On Error Resume Next
    SheetExists = Not wb.Worksheets(name) Is Nothing
    On Error GoTo 0
End Function
