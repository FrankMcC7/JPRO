Option Explicit

' =============================================================
' POST-REMEDIATION QC (uses frmCoperBatches; no UI blocking; Keys normalization)
' Entry:  Run_PostQC_Start_PQC   → prepares batches, shows form, exits.
' Button: frmCoperBatches.Move On → calls Run_PostQC_Continue_PQC.
' =============================================================

' ---- If these globals already exist elsewhere, DELETE these 4 lines to avoid duplicates ----
Public G_Batches() As String
Public G_BatchIndex As Long
Public G_BatchCount As Long
Public G_WorkflowReadyToContinue As Boolean
' -------------------------------------------------------------------------------------------

' =============== ENTRY: pick Iteration, build targets, prep batches, show form, EXIT =======
Public Sub Run_PostQC_Start_PQC()
    On Error GoTo Fail

    Dim iterPath As String
    Dim wbIter As Workbook, wsSum As Worksheet
    Dim targetMap As Object, targetList() As String
    Dim batchSize As Long: batchSize = 600

    ' 1) Pick Iteration workbook
    iterPath = PQC_PickFile("Select the Iteration workbook (Iteration_MMM-YYYY.xlsx)", "Excel Files (*.xlsx)", "*.xlsx")
    If Len(iterPath) = 0 Then Exit Sub

    Set wbIter = Workbooks.Open(Filename:=iterPath, ReadOnly:=False)

    ' 2) Locate CoR Mismatch Summary (tolerant name check)
    If PQC_SheetExists(wbIter, "CoR Mismatch Summary") Then
        Set wsSum = wbIter.Worksheets("CoR Mismatch Summary")
    Else
        Dim wsTry As Worksheet
        For Each wsTry In wbIter.Worksheets
            If LCase$(Trim$(wsTry.Name)) Like "cor mismatch summary*" Then
                Set wsSum = wsTry
                Exit For
            End If
        Next
        If wsSum Is Nothing Then
            MsgBox "'CoR Mismatch Summary' not found in the selected iteration file.", vbCritical
            GoTo Cleanup
        End If
    End If

    ' 3) Parse mismatch summary → targetMap (coper -> Approved CoR) + unique list for batching
    Set targetMap = CreateObject("Scripting.Dictionary")
    PQC_ParseMismatchSummaryToTargets wsSum, targetMap, targetList
    If targetMap.Count = 0 Then
        MsgBox "No copers found in 'CoR Mismatch Summary'. Nothing to QC.", vbInformation
        GoTo Cleanup
    End If

    ' 4) Cache targets inside Iteration (hidden sheet; no string size limits)
    PQC_SaveTargetsForContinuation wbIter, targetMap

    ' 5) Remember Iteration path in this main workbook
    PQC_SavePathName ThisWorkbook, "__PQC_ITERATION_PATH__", iterPath

    ' 6) Prepare batches for your modeless form; DO NOT block Excel
    PQC_FillBatchGlobals targetList, batchSize
    G_WorkflowReadyToContinue = False
    frmCoperBatches.Show vbModeless

    MsgBox "Batches prepared. Paste each batch into Credit Studio and export the updated data." & vbCrLf & _
           "When done exporting, click 'Move On' on the form to continue.", vbInformation
    Exit Sub

Cleanup:
    On Error Resume Next
    If Not wbIter Is Nothing Then wbIter.Close SaveChanges:=False
    On Error GoTo 0
    Exit Sub

Fail:
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical
    Resume Cleanup
End Sub

' =============== CONTINUATION: called by your form’s Move On button ========================
Public Sub Run_PostQC_Continue_PQC()
    On Error GoTo Fail

    Dim iterPath As String
    Dim wbIter As Workbook
    Dim targetMap As Object

    ' 1) Reload Iteration and targets
    iterPath = PQC_ReadPathName(ThisWorkbook, "__PQC_ITERATION_PATH__")
    If Len(iterPath) = 0 Then
        MsgBox "Iteration file path not found. Please run 'Run_PostQC_Start_PQC' first.", vbCritical
        Exit Sub
    End If
    Set wbIter = Workbooks.Open(Filename:=iterPath, ReadOnly:=False)

    Set targetMap = PQC_LoadTargetsForContinuation(wbIter)
    If targetMap Is Nothing Or targetMap.Count = 0 Then
        MsgBox "Targets not found in the Iteration file. Please run 'Run_PostQC_Start_PQC' again.", vbCritical
        GoTo Cleanup
    End If

    ' 2) Pick UPDATED Credit Studio file(s)
    Dim creditFiles As Collection, p As Variant
    Dim wbCredit As Workbook, loCredit As ListObject
    Set creditFiles = PQC_PickFilesMulti("Select the UPDATED Credit Studio XLSX file(s) after rectification", "Excel Files (*.xlsx)", "*.xlsx")
    If creditFiles Is Nothing Or creditFiles.Count = 0 Then
        MsgBox "No updated Credit Studio files selected. Stopping.", vbInformation
        GoTo Cleanup
    End If

    ' 3) Build updated credit dict (coper -> Credit CoR)
    Dim creditUpdated As Object: Set creditUpdated = CreateObject("Scripting.Dictionary")
    For Each p In creditFiles
        Set wbCredit = Workbooks.Open(Filename:=CStr(p), ReadOnly:=True)
        Set loCredit = PQC_EnsureTable(wbCredit.Worksheets(1), "PQC_CreditTbl")
        PQC_AppendCreditToDict loCredit, creditUpdated, "Coper ID", "Country of Risk"
        wbCredit.Close SaveChanges:=False
    Next p

    ' 4) Load Keys map from MAIN workbook (this macro host)
    Dim keysMap As Object
    Set keysMap = PQC_LoadKeysMap(ThisWorkbook) ' empty dict if Keys sheet not present

    ' 5) Compare with Keys normalization; write Post-Remediation QC into Iteration:Stats
    PQC_WritePostRemediationStats wbIter, targetMap, creditUpdated, keysMap

    wbIter.Save
    MsgBox "Post-Remediation QC complete. Stats updated in the Iteration file.", vbInformation

Cleanup:
    On Error Resume Next
    If Not wbIter Is Nothing Then wbIter.Close SaveChanges:=True
    On Error GoTo 0
    Exit Sub

Fail:
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical
    Resume Cleanup
End Sub

' =========================== TARGET BUILDING ===========================
Private Sub PQC_ParseMismatchSummaryToTargets(ByVal ws As Worksheet, ByRef outMap As Object, ByRef outList() As String)
    Dim colCoR As Long, colCopers As Long
    colCoR = PQC_FindHeader(ws, "Country of Risk (AllFund, post-Keys normalization)")
    colCopers = PQC_FindHeader(ws, "Coper IDs with wrong CoR in Credit Studio (comma-joined)")
    If colCoR = 0 Then colCoR = PQC_FindHeader(ws, "Country of Risk")
    If colCopers = 0 Then colCopers = PQC_FindHeader(ws, "Coper IDs")
    If colCoR = 0 Or colCopers = 0 Then Err.Raise vbObjectError + 8101, , "CoR Mismatch Summary: columns not found."

    Dim lastRow As Long: lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    Dim r As Long, aCoR As String, listStr As String, arr() As String, i As Long
    Dim uniq As Object: Set uniq = CreateObject("Scripting.Dictionary")

    For r = 2 To lastRow
        aCoR = Trim$(CStr(ws.Cells(r, colCoR).Value))
        listStr = Trim$(CStr(ws.Cells(r, colCopers).Value))
        If Len(aCoR) > 0 And Len(listStr) > 0 Then
            arr = Split(listStr, ",")
            For i = LBound(arr) To UBound(arr)
                Dim cid As String
                cid = PQC_SanitizeCoperID(arr(i))
                If Len(cid) > 0 Then
                    outMap(cid) = aCoR
                    If Not uniq.Exists(cid) Then uniq.Add cid, True
                End If
            Next i
        End If
    Next r

    If uniq.Count > 0 Then
        ReDim outList(1 To uniq.Count)
        Dim k As Variant, n As Long: n = 0
        For Each k In uniq.Keys
            n = n + 1
            outList(n) = CStr(k)
        Next k
    Else
        Erase outList
    End If
End Sub

' ============================= BATCHING ================================
Private Sub PQC_FillBatchGlobals(ByRef ids() As String, ByVal batchSize As Long)
    Dim total As Long, batches As Long, b As Long, sIdx As Long, eIdx As Long
    If Not PQC_IsArrayAllocated(ids) Then Err.Raise vbObjectError + 8201, , "No coper IDs to batch."

    total = UBound(ids) - LBound(ids) + 1
    batches = (total \ batchSize) + IIf(total Mod batchSize = 0, 0, 1)

    ReDim G_Batches(1 To batches)
    For b = 1 To batches
        sIdx = (b - 1) * batchSize + 1
        eIdx = WorksheetFunction.Min(b * batchSize, total)
        G_Batches(b) = PQC_JoinRange(ids, sIdx, eIdx, ",")
    Next b

    G_BatchIndex = 1
    G_BatchCount = batches
End Sub

Private Function PQC_IsArrayAllocated(ByRef arr() As String) As Boolean
    On Error GoTo EH
    Dim lb As Long, ub As Long
    lb = LBound(arr): ub = UBound(arr)
    PQC_IsArrayAllocated = (ub >= lb)
    Exit Function
EH:
    PQC_IsArrayAllocated = False
End Function

Private Function PQC_JoinRange(ByRef arr() As String, ByVal startIdx As Long, ByVal endIdx As Long, ByVal delim As String) As String
    Dim i As Long, s As String
    For i = startIdx To endIdx
        If Len(s) > 0 Then s = s & delim
        s = s & arr(i)
    Next i
    PQC_JoinRange = s
End Function

' ============================= CREDIT INGEST ===========================
Private Sub PQC_AppendCreditToDict(ByVal lo As ListObject, ByRef creditDict As Object, _
                                   ByVal coperHeader As String, ByVal corHeader As String)
    Dim idxC As Long, idxR As Long
    idxC = PQC_GetColumnIndex(lo, coperHeader)
    idxR = PQC_GetColumnIndex(lo, corHeader)
    If idxC = 0 Then Err.Raise vbObjectError + 8301, , "Credit column '" & coperHeader & "' not found."
    If idxR = 0 Then Err.Raise vbObjectError + 8302, , "Credit column '" & corHeader & "' not found."
    If lo.DataBodyRange Is Nothing Then Exit Sub

    Dim r As Long, cid As String, cor As String
    For r = 1 To lo.DataBodyRange.Rows.Count
        cid = PQC_SanitizeCoperID(lo.DataBodyRange.Cells(r, idxC).Value)
        If Len(cid) > 0 Then
            cor = Trim$(CStr(lo.DataBodyRange.Cells(r, idxR).Value))
            creditDict(cid) = cor  ' last wins
        End If
    Next r
End Sub

' ============================= KEYS (normalization) ====================
Private Function PQC_LoadKeysMap(ByVal wbMain As Workbook) As Object
    Dim dict As Object: Set dict = CreateObject("Scripting.Dictionary")
    On Error GoTo Done

    Dim ws As Worksheet, lo As ListObject
    Set ws = wbMain.Worksheets("Keys")
    Set lo = ws.ListObjects("Keys")

    Dim idxAF As Long, idxCS As Long, r As Long
    idxAF = PQC_ListColumnIndex(lo, "All Funds")
    idxCS = PQC_ListColumnIndex(lo, "Credit Studio")
    If idxAF = 0 Or idxCS = 0 Then GoTo Done

    Dim af As String, cs As String, canon As String
    If Not lo.DataBodyRange Is Nothing Then
        For r = 1 To lo.DataBodyRange.Rows.Count
            af = LCase$(Trim$(CStr(lo.DataBodyRange.Cells(r, idxAF).Value)))
            cs = LCase$(Trim$(CStr(lo.DataBodyRange.Cells(r, idxCS).Value)))
            If Len(af) > 0 And Len(cs) > 0 Then
                canon = af
                dict(af) = canon
                dict(cs) = canon
            End If
        Next r
    End If
Done:
    Set PQC_LoadKeysMap = dict
End Function

Private Function PQC_NormalizeCoR(ByVal v As String, ByVal keysMap As Object) As String
    Dim k As String: k = LCase$(Trim$(v))
    If Len(k) = 0 Then PQC_NormalizeCoR = k: Exit Function
    If Not keysMap Is Nothing Then
        If keysMap.Exists(k) Then PQC_NormalizeCoR = keysMap(k): Exit Function
    End If
    PQC_NormalizeCoR = k
End Function

' ============================= STATS WRITER ============================
Private Sub PQC_WritePostRemediationStats(ByVal iterWb As Workbook, _
                                          ByVal targetMap As Object, _
                                          ByVal creditUpdated As Object, _
                                          ByVal keysMap As Object)

    Dim ws As Worksheet
    If PQC_SheetExists(iterWb, "Stats") Then
        Set ws = iterWb.Worksheets("Stats")
    Else
        Set ws = iterWb.Worksheets.Add(After:=iterWb.Sheets(iterWb.Sheets.Count))
        ws.Name = "Stats"
    End If

    Dim row As Long
    row = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    If row < 1 Then row = 1 Else row = row + 2

    With ws.Cells(row, 1)
        .Value = "Post-Remediation QC"
        .Font.Bold = True
        .Font.Size = 14
    End With
    row = row + 1

    Dim totalTarget As Long, foundInCredit As Long, rectified As Long, stillMismatch As Long, notFound As Long
    Dim k As Variant, expected As String, got As String
    Dim expectedN As String, gotN As String

    totalTarget = targetMap.Count

    For Each k In targetMap.Keys
        expected = Trim$(CStr(targetMap(k)))
        expectedN = PQC_NormalizeCoR(expected, keysMap)

        If creditUpdated.Exists(k) Then
            foundInCredit = foundInCredit + 1
            got = Trim$(CStr(creditUpdated(k)))
            gotN = PQC_NormalizeCoR(got, keysMap)

            If StrComp(expectedN, gotN, vbTextCompare) = 0 Then
                rectified = rectified + 1
            Else
                stillMismatch = stillMismatch + 1
            End If
        Else
            notFound = notFound + 1
        End If
    Next k

    ' Table
    ws.Cells(row, 1).Value = "Metric"
    ws.Cells(row, 2).Value = "Count"
    ws.Cells(row, 3).Value = "% of Target"
    ws.Range(ws.Cells(row, 1), ws.Cells(row, 3)).Font.Bold = True
    row = row + 1

    Dim startTbl As Long: startTbl = row
    ws.Cells(row, 1).Value = "Target Copers (from CoR Mismatch Summary)": ws.Cells(row, 2).Value = totalTarget: ws.Cells(row, 3).Value = PQC_SafePercent(totalTarget, totalTarget): row = row + 1
    ws.Cells(row, 1).Value = "Found in Updated Credit":                   ws.Cells(row, 2).Value = foundInCredit: ws.Cells(row, 3).Value = PQC_SafePercent(foundInCredit, totalTarget): row = row + 1
    ws.Cells(row, 1).Value = "Rectified (after Keys normalization)":       ws.Cells(row, 2).Value = rectified: ws.Cells(row, 3).Value = PQC_SafePercent(rectified, totalTarget): row = row + 1
    ws.Cells(row, 1).Value = "Still Mismatched":                           ws.Cells(row, 2).Value = stillMismatch: ws.Cells(row, 3).Value = PQC_SafePercent(stillMismatch, totalTarget): row = row + 1
    ws.Cells(row, 1).Value = "Not Found in Updated Credit":                ws.Cells(row, 2).Value = notFound: ws.Cells(row, 3).Value = PQC_SafePercent(notFound, totalTarget): row = row + 1

    Dim lo As ListObject
    Set lo = ws.ListObjects.Add(xlSrcRange, ws.Range(ws.Cells(startTbl - 1, 1), ws.Cells(row - 1, 3)), , xlYes)
    On Error Resume Next
    lo.Name = "PostRemediationQCTbl"
    lo.TableStyle = "TableStyleMedium9"
    On Error GoTo 0
    ws.Range(ws.Cells(startTbl, 3), ws.Cells(row - 1, 3)).NumberFormat = "0.0%"
    ws.Columns.AutoFit
End Sub

' ===================== TARGET CACHE (hidden sheet in Iteration) ============================
Private Sub PQC_SaveTargetsForContinuation(ByVal wbIter As Workbook, ByVal targetMap As Object)
    Dim ws As Worksheet, k As Variant, r As Long
    On Error Resume Next
    Application.DisplayAlerts = False
    wbIter.Worksheets("__PQC_CACHE__").Delete
    Application.DisplayAlerts = True
    On Error GoTo 0

    Set ws = wbIter.Worksheets.Add(After:=wbIter.Sheets(wbIter.Sheets.Count))
    ws.Name = "__PQC_CACHE__"
    ws.Visible = xlSheetVeryHidden

    ws.Cells(1, 1).Value = "CoperID"
    ws.Cells(1, 2).Value = "ApprovedCoR"

    r = 2
    For Each k In targetMap.Keys
        ws.Cells(r, 1).Value = CStr(k)
        ws.Cells(r, 2).Value = CStr(targetMap(k))
        r = r + 1
    Next k
End Sub

Private Function PQC_LoadTargetsForContinuation(ByVal wbIter As Workbook) As Object
    Dim ws As Worksheet, lastRow As Long, r As Long
    Dim d As Object: Set d = CreateObject("Scripting.Dictionary")

    On Error Resume Next
    Set ws = wbIter.Worksheets("__PQC_CACHE__")
    On Error GoTo 0
    If ws Is Nothing Then Set PQC_LoadTargetsForContinuation = Nothing: Exit Function

    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    If lastRow < 2 Then Set PQC_LoadTargetsForContinuation = d: Exit Function

    For r = 2 To lastRow
        Dim cid As String, cor As String
        cid = Trim$(CStr(ws.Cells(r, 1).Value))
        cor = Trim$(CStr(ws.Cells(r, 2).Value))
        If Len(cid) > 0 Then d(cid) = cor
    Next r
    Set PQC_LoadTargetsForContinuation = d
End Function

' =========================== PATH PERSISTENCE (short string) ===============================
Private Sub PQC_SavePathName(ByVal wb As Workbook, ByVal nm As String, ByVal path As String)
    On Error Resume Next
    wb.Names(nm).Delete
    On Error GoTo 0
    wb.Names.Add Name:=nm, RefersTo:="=""" & path & """"
End Sub

Private Function PQC_ReadPathName(ByVal wb As Workbook, ByVal nm As String) As String
    On Error Resume Next
    Dim n As Name: Set n = wb.Names(nm)
    On Error GoTo 0
    If n Is Nothing Then Exit Function
    Dim s As String: s = n.RefersTo
    s = Replace(s, "=", "")
    s = Replace(s, """", "")
    PQC_ReadPathName = s
End Function

' ============================= UTILITIES (sheet/headers/table) =============================
Private Function PQC_SheetExists(ByVal wb As Workbook, ByVal name As String) As Boolean
    On Error Resume Next
    PQC_SheetExists = Not wb.Worksheets(name) Is Nothing
    On Error GoTo 0
End Function

Private Function PQC_FindHeader(ByVal ws As Worksheet, ByVal headerName As String) As Long
    Dim lastCol As Long, c As Long, target As String, val As String
    If ws Is Nothing Then Exit Function
    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    If lastCol < 1 Then Exit Function
    target = LCase$(Trim$(headerName))
    For c = 1 To lastCol
        val = LCase$(Trim$(CStr(ws.Cells(1, c).Value)))
        If val = target Then PQC_FindHeader = c: Exit Function
    Next c
End Function

Private Function PQC_SanitizeCoperID(ByVal v As Variant) As String
    Dim s As String
    s = Trim$(CStr(v))
    s = Replace(s, ",", "")
    s = Replace(s, " ", "")
    s = Replace(s, Chr$(160), "")
    PQC_SanitizeCoperID = s
End Function

Private Function PQC_EnsureTable(ByVal ws As Worksheet, ByVal tableName As String) As ListObject
    Dim lo As ListObject, rng As Range
    If ws.ListObjects.Count > 0 Then
        Set lo = ws.ListObjects(1)
        On Error Resume Next: lo.Name = tableName: On Error GoTo 0
        Set PQC_EnsureTable = lo: Exit Function
    End If
    Set rng = PQC_TrimUsedRange(ws)
    If rng Is Nothing Then Err.Raise vbObjectError + 8401, , "No data found on sheet '" & ws.Name & "'."
    Set lo = ws.ListObjects.Add(xlSrcRange, rng, , xlYes)
    On Error Resume Next: lo.Name = tableName: On Error GoTo 0
    Set PQC_EnsureTable = lo
End Function

Private Function PQC_TrimUsedRange(ByVal ws As Worksheet) As Range
    Dim ur As Range, r1 As Long, r2 As Long, c1 As Long, c2 As Long
    Set ur = ws.UsedRange
    If ur Is Nothing Then Exit Function
    r1 = ur.Row: r2 = ur.Rows(ur.Rows.Count).Row
    c1 = ur.Column: c2 = ur.Columns(ur.Columns.Count).Column
    Do While r1 <= r2 And Application.CountA(ws.Rows(r1)) = 0: r1 = r1 + 1: Loop
    Do While r2 >= r1 And Application.CountA(ws.Rows(r2)) = 0: r2 = r2 - 1: Loop
    Do While c1 <= c2 And Application.CountA(ws.Columns(c1)) = 0: c1 = c1 + 1: Loop
    Do While c2 >= c1 And Application.CountA(ws.Columns(c2)) = 0: c2 = c2 - 1: Loop
    If r2 < r1 Or c2 < c1 Then
        Set PQC_TrimUsedRange = Nothing
    Else
        Set PQC_TrimUsedRange = ws.Range(ws.Cells(r1, c1), ws.Cells(r2, c2))
    End If
End Function

Private Function PQC_GetColumnIndex(ByVal lo As ListObject, ByVal headerName As String) As Long
    Dim i As Long
    For i = 1 To lo.HeaderRowRange.Columns.Count
        If Trim$(LCase$(CStr(lo.HeaderRowRange.Cells(1, i).Value))) = Trim$(LCase$(headerName)) Then
            PQC_GetColumnIndex = i: Exit Function
        End If
    Next i
    PQC_GetColumnIndex = 0
End Function

Private Function PQC_ListColumnIndex(ByVal lo As ListObject, ByVal headerName As String) As Long
    Dim i As Long
    For i = 1 To lo.HeaderRowRange.Columns.Count
        If Trim$(LCase$(CStr(lo.HeaderRowRange.Cells(1, i).Value))) = Trim$(LCase$(headerName)) Then
            PQC_ListColumnIndex = i: Exit Function
        End If
    Next i
End Function

' ============================= FILE PICKERS & MATH =============================
Private Function PQC_PickFile(ByVal promptTitle As String, ByVal filterDesc As String, ByVal filterPattern As String) As String
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = promptTitle
        .Filters.Clear
        .Filters.Add filterDesc, filterPattern
        .AllowMultiSelect = False
        If .Show = -1 Then PQC_PickFile = .SelectedItems(1)
    End With
End Function

Private Function PQC_PickFilesMulti(ByVal promptTitle As String, _
                                    ByVal filterDesc As String, _
                                    ByVal filterPattern As String) As Collection
    Dim fd As FileDialog, i As Long
    Dim c As New Collection
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = promptTitle
        .Filters.Clear
        .Filters.Add filterDesc, filterPattern
        .AllowMultiSelect = True
        If .Show = -1 Then
            For i = 1 To .SelectedItems.Count
                c.Add .SelectedItems(i)
            Next i
        End If
    End With
    Set PQC_PickFilesMulti = c
End Function

Private Function PQC_SafePercent(ByVal num As Long, ByVal den As Long) As Double
    If den <= 0 Then PQC_SafePercent = 0 Else PQC_SafePercent = num / den
End Function
