Option Explicit

' =============================================================
' Post-Remediation QC (uses your frmCoperBatches userform)
' All helpers are prefixed PQC_* to avoid name collisions.
' =============================================================

Public Sub Run_PostRectification_QC_UsingForm_PQC()
    On Error GoTo Fail

    Dim iterPath As String
    Dim wbIter As Workbook, wsSum As Worksheet
    Dim targetMap As Object            ' coper -> Approved CoR
    Dim targetList() As String         ' 1-based array (unique copers)
    Dim batchSize As Long: batchSize = 600

    ' 1) Pick the Iteration workbook
    iterPath = PQC_PickFile("Select the Iteration workbook (Iteration_MMM-YYYY.xlsx)", "Excel Files (*.xlsx)", "*.xlsx")
    If Len(iterPath) = 0 Then Exit Sub

    Set wbIter = Workbooks.Open(Filename:=iterPath, ReadOnly:=False)
    If Not PQC_SheetExists(wbIter, "CoR Mismatch Summary") Then
        MsgBox "'CoR Mismatch Summary' not found in the selected iteration file.", vbCritical
        GoTo Cleanup
    End If
    Set wsSum = wbIter.Worksheets("CoR Mismatch Summary")

    ' 2) Build target map/list from "CoR Mismatch Summary"
    Set targetMap = CreateObject("Scripting.Dictionary")
    PQC_ParseMismatchSummaryToTargets wsSum, targetMap, targetList
    If targetMap.Count = 0 Then
        MsgBox "No copers found in 'CoR Mismatch Summary'. Nothing to QC.", vbInformation
        GoTo Cleanup
    End If

    ' 3) Batch via your modeless userform (uses your existing globals)
    PQC_FillBatchGlobals targetList, batchSize      ' sets G_Batches(), G_BatchIndex, G_BatchCount
    G_WorkflowReadyToContinue = False
    frmCoperBatches.Show vbModeless

    MsgBox "Batches prepared. Paste each batch into Credit Studio and export the updated data." & vbCrLf & _
           "When done exporting, click 'Move On' on the form to continue.", vbInformation

    ' Wait until your form toggles the continue flag
    Do While Not G_WorkflowReadyToContinue
        DoEvents
        Application.Wait Now + TimeSerial(0, 0, 1)
    Loop

    ' 4) Pick UPDATED Credit Studio XLSX file(s)
    Dim creditFiles As Collection, p As Variant
    Dim wbCredit As Workbook, loCredit As ListObject
    Set creditFiles = PQC_PickFilesMulti("Select the UPDATED Credit Studio XLSX file(s) after rectification", "Excel Files (*.xlsx)", "*.xlsx")
    If creditFiles Is Nothing Or creditFiles.Count = 0 Then
        MsgBox "No updated Credit Studio files selected. Stopping.", vbInformation
        GoTo Cleanup
    End If

    ' 5) Build updated credit map (coper -> Credit CoR)
    Dim creditUpdated As Object: Set creditUpdated = CreateObject("Scripting.Dictionary")
    For Each p In creditFiles
        Set wbCredit = Workbooks.Open(Filename:=CStr(p), ReadOnly:=True)
        Set loCredit = PQC_EnsureTable(wbCredit.Worksheets(1), "PQC_CreditTbl")
        PQC_AppendCreditToDict loCredit, creditUpdated, "Coper ID", "Country of Risk"
        wbCredit.Close SaveChanges:=False
    Next p

    ' 6) Compare & write Post-Remediation QC section into Iteration:Stats
    PQC_WritePostRemediationStats wbIter, targetMap, creditUpdated

    ' 7) Save iteration workbook
    wbIter.Save
    MsgBox "Post-Remediation QC complete. Stats updated in the Iteration file.", vbInformation

Cleanup:
    On Error Resume Next
    If Not wbIter Is Nothing Then wbIter.Close SaveChanges:=True
    On Error GoTo 0
    Exit Sub

Fail:
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical
    Resume Cleanup
End Sub

' ---------------------------
' Parse CoR Mismatch Summary
' ---------------------------
Private Sub PQC_ParseMismatchSummaryToTargets(ByVal ws As Worksheet, ByRef outMap As Object, ByRef outList() As String)
    Dim colCoR As Long, colCopers As Long
    colCoR = PQC_FindHeader(ws, "Country of Risk (AllFund, post-Keys normalization)")
    colCopers = PQC_FindHeader(ws, "Coper IDs with wrong CoR in Credit Studio (comma-joined)")

    ' fallback if headers were edited
    If colCoR = 0 Then colCoR = PQC_FindHeader(ws, "Country of Risk")
    If colCopers = 0 Then colCopers = PQC_FindHeader(ws, "Coper IDs")

    If colCoR = 0 Or colCopers = 0 Then Err.Raise vbObjectError + 6501, , "CoR Mismatch Summary: columns not found."

    Dim lastRow As Long: lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    Dim r As Long, aCoR As String, listStr As String, arr() As String, i As Long
    Dim uniq As Object: Set uniq = CreateObject("Scripting.Dictionary")

    For r = 2 To lastRow
        aCoR = Trim$(CStr(ws.Cells(r, colCoR).Value))
        listStr = Trim$(CStr(ws.Cells(r, colCopers).Value))
        If Len(aCoR) > 0 And Len(listStr) > 0 Then
            arr = Split(listStr, ",")
            For i = LBound(arr) To UBound(arr)
                Dim cid As String
                cid = PQC_SanitizeCoperID(arr(i))
                If Len(cid) > 0 Then
                    outMap(cid) = aCoR
                    If Not uniq.Exists(cid) Then uniq.Add cid, True
                End If
            Next i
        End If
    Next r

    If uniq.Count > 0 Then
        ReDim outList(1 To uniq.Count)
        Dim k As Variant, n As Long: n = 0
        For Each k In uniq.Keys
            n = n + 1
            outList(n) = CStr(k)
        Next k
    Else
        Erase outList
    End If
End Sub

' ---------------------------
' Batch fill for your form
' ---------------------------
Private Sub PQC_FillBatchGlobals(ByRef ids() As String, ByVal batchSize As Long)
    Dim total As Long, batches As Long, b As Long, sIdx As Long, eIdx As Long

    If Not PQC_IsArrayAllocated(ids) Then Err.Raise vbObjectError + 6502, , "No coper IDs to batch."

    total = UBound(ids) - LBound(ids) + 1
    batches = (total \ batchSize) + IIf(total Mod batchSize = 0, 0, 1)

    ReDim G_Batches(1 To batches)
    For b = 1 To batches
        sIdx = (b - 1) * batchSize + 1
        eIdx = WorksheetFunction.Min(b * batchSize, total)
        G_Batches(b) = PQC_JoinRange(ids, sIdx, eIdx, ",")
    Next b

    G_BatchIndex = 1
    G_BatchCount = batches
End Sub

Private Function PQC_IsArrayAllocated(ByRef arr() As String) As Boolean
    On Error GoTo EH
    Dim lb As Long, ub As Long
    lb = LBound(arr): ub = UBound(arr)
    PQC_IsArrayAllocated = (ub >= lb)
    Exit Function
EH:
    PQC_IsArrayAllocated = False
End Function

Private Function PQC_JoinRange(ByRef arr() As String, ByVal startIdx As Long, ByVal endIdx As Long, ByVal delim As String) As String
    Dim i As Long, s As String
    For i = startIdx To endIdx
        If Len(s) > 0 Then s = s & delim
        s = s & arr(i)
    Next i
    PQC_JoinRange = s
End Function

' ---------------------------
' Ingest updated Credit files
' ---------------------------
Private Sub PQC_AppendCreditToDict(ByVal lo As ListObject, ByRef creditDict As Object, _
                                   ByVal coperHeader As String, ByVal corHeader As String)
    Dim idxC As Long, idxR As Long
    idxC = PQC_GetColumnIndex(lo, coperHeader)
    idxR = PQC_GetColumnIndex(lo, corHeader)
    If idxC = 0 Then Err.Raise vbObjectError + 6701, , "Credit column '" & coperHeader & "' not found."
    If idxR = 0 Then Err.Raise vbObjectError + 6702, , "Credit column '" & corHeader & "' not found."
    If lo.DataBodyRange Is Nothing Then Exit Sub

    Dim r As Long, cid As String, cor As String
    For r = 1 To lo.DataBodyRange.Rows.Count
        cid = PQC_SanitizeCoperID(lo.DataBodyRange.Cells(r, idxC).Value)
        If Len(cid) > 0 Then
            cor = Trim$(CStr(lo.DataBodyRange.Cells(r, idxR).Value))
            creditDict(cid) = cor  ' last wins
        End If
    Next r
End Sub

' ---------------------------
' Write QC summary to Stats
' ---------------------------
Private Sub PQC_WritePostRemediationStats(ByVal iterWb As Workbook, _
                                          ByVal targetMap As Object, _
                                          ByVal creditUpdated As Object)

    Dim ws As Worksheet
    If PQC_SheetExists(iterWb, "Stats") Then
        Set ws = iterWb.Worksheets("Stats")
    Else
        Set ws = iterWb.Worksheets.Add(After:=iterWb.Sheets(iterWb.Sheets.Count))
        ws.Name = "Stats"
    End If

    Dim row As Long
    row = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    If row < 1 Then row = 1 Else row = row + 2

    With ws.Cells(row, 1)
        .Value = "Post-Remediation QC"
        .Font.Bold = True
        .Font.Size = 14
    End With
    row = row + 1

    Dim totalTarget As Long, foundInCredit As Long, rectified As Long, stillMismatch As Long, notFound As Long
    Dim k As Variant, expected As String, got As String

    totalTarget = targetMap.Count

    For Each k In targetMap.Keys
        expected = Trim$(CStr(targetMap(k)))
        If creditUpdated.Exists(k) Then
            foundInCredit = foundInCredit + 1
            got = Trim$(CStr(creditUpdated(k)))
            If StrComp(expected, got, vbTextCompare) = 0 Then
                rectified = rectified + 1
            Else
                stillMismatch = stillMismatch + 1
            End If
        Else
            notFound = notFound + 1
        End If
    Next k

    ws.Cells(row, 1).Value = "Metric"
    ws.Cells(row, 2).Value = "Count"
    ws.Cells(row, 3).Value = "% of Target"
    ws.Range(ws.Cells(row, 1), ws.Cells(row, 3)).Font.Bold = True
    row = row + 1

    Dim startTbl As Long: startTbl = row
    ws.Cells(row, 1).Value = "Target Copers (from CoR Mismatch Summary)": ws.Cells(row, 2).Value = totalTarget: ws.Cells(row, 3).Value = PQC_SafePercent(totalTarget, totalTarget): row = row + 1
    ws.Cells(row, 1).Value = "Found in Updated Credit":                   ws.Cells(row, 2).Value = foundInCredit: ws.Cells(row, 3).Value = PQC_SafePercent(foundInCredit, totalTarget): row = row + 1
    ws.Cells(row, 1).Value = "Rectified (Credit CoR now matches Approved)": ws.Cells(row, 2).Value = rectified: ws.Cells(row, 3).Value = PQC_SafePercent(rectified, totalTarget): row = row + 1
    ws.Cells(row, 1).Value = "Still Mismatched":                           ws.Cells(row, 2).Value = stillMismatch: ws.Cells(row, 3).Value = PQC_SafePercent(stillMismatch, totalTarget): row = row + 1
    ws.Cells(row, 1).Value = "Not Found in Updated Credit":                ws.Cells(row, 2).Value = notFound: ws.Cells(row, 3).Value = PQC_SafePercent(notFound, totalTarget): row = row + 1

    Dim lo As ListObject
    Set lo = ws.ListObjects.Add(xlSrcRange, ws.Range(ws.Cells(startTbl - 1, 1), ws.Cells(row - 1, 3)), , xlYes)
    On Error Resume Next
    lo.Name = "PostRemediationQCTbl"
    lo.TableStyle = "TableStyleMedium9"
    On Error GoTo 0
    ws.Range(ws.Cells(startTbl, 3), ws.Cells(row - 1, 3)).NumberFormat = "0.0%"
    ws.Columns.AutoFit
End Sub

' ---------------------------
' Utilities (sheet/headers)
' ---------------------------
Private Function PQC_SheetExists(ByVal wb As Workbook, ByVal name As String) As Boolean
    On Error Resume Next
    PQC_SheetExists = Not wb.Worksheets(name) Is Nothing
    On Error GoTo 0
End Function

Private Function PQC_FindHeader(ByVal ws As Worksheet, ByVal headerName As String) As Long
    Dim lastCol As Long, c As Long, target As String, val As String
    If ws Is Nothing Then Exit Function
    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    If lastCol < 1 Then Exit Function

    target = LCase$(Trim$(headerName))
    For c = 1 To lastCol
        val = LCase$(Trim$(CStr(ws.Cells(1, c).Value)))
        If val = target Then
            PQC_FindHeader = c
            Exit Function
        End If
    Next c
End Function

Private Function PQC_SanitizeCoperID(ByVal v As Variant) As String
    Dim s As String
    s = Trim$(CStr(v))
    s = Replace(s, ",", "")
    s = Replace(s, " ", "")
    s = Replace(s, Chr$(160), "")
    PQC_SanitizeCoperID = s
End Function

' ---------------------------
' EnsureTable + helpers (renamed)
' ---------------------------
Private Function PQC_EnsureTable(ByVal ws As Worksheet, ByVal tableName As String) As ListObject
    Dim lo As ListObject, rng As Range
    If ws.ListObjects.Count > 0 Then
        Set lo = ws.ListObjects(1)
        On Error Resume Next
        lo.Name = tableName
        On Error GoTo 0
        Set PQC_EnsureTable = lo
        Exit Function
    End If
    Set rng = PQC_TrimUsedRange(ws)
    If rng Is Nothing Then Err.Raise vbObjectError + 6801, , "No data found on sheet '" & ws.Name & "'."
    Set lo = ws.ListObjects.Add(xlSrcRange, rng, , xlYes)
    On Error Resume Next
    lo.Name = tableName
    On Error GoTo 0
    Set PQC_EnsureTable = lo
End Function

Private Function PQC_TrimUsedRange(ByVal ws As Worksheet) As Range
    Dim ur As Range, r1 As Long, r2 As Long, c1 As Long, c2 As Long
    Set ur = ws.UsedRange
    If ur Is Nothing Then Exit Function
    r1 = ur.Row: r2 = ur.Rows(ur.Rows.Count).Row
    c1 = ur.Column: c2 = ur.Columns(ur.Columns.Count).Column
    Do While r1 <= r2 And Application.CountA(ws.Rows(r1)) = 0: r1 = r1 + 1: Loop
    Do While r2 >= r1 And Application.CountA(ws.Rows(r2)) = 0: r2 = r2 - 1: Loop
    Do While c1 <= c2 And Application.CountA(ws.Columns(c1)) = 0: c1 = c1 + 1: Loop
    Do While c2 >= c1 And Application.CountA(ws.Columns(c2)) = 0: c2 = c2 - 1: Loop
    If r2 < r1 Or c2 < c1 Then
        Set PQC_TrimUsedRange = Nothing
    Else
        Set PQC_TrimUsedRange = ws.Range(ws.Cells(r1, c1), ws.Cells(r2, c2))
    End If
End Function

Private Function PQC_GetColumnIndex(ByVal lo As ListObject, ByVal headerName As String) As Long
    Dim i As Long
    For i = 1 To lo.HeaderRowRange.Columns.Count
        If Trim$(LCase$(CStr(lo.HeaderRowRange.Cells(1, i).Value))) = Trim$(LCase$(headerName)) Then
            PQC_GetColumnIndex = i
            Exit Function
        End If
    Next i
    PQC_GetColumnIndex = 0
End Function

' ---------------------------
' File pickers (renamed)
' ---------------------------
Private Function PQC_PickFile(ByVal promptTitle As String, ByVal filterDesc As String, ByVal filterPattern As String) As String
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = promptTitle
        .Filters.Clear
        .Filters.Add filterDesc, filterPattern
        .AllowMultiSelect = False
        If .Show = -1 Then PQC_PickFile = .SelectedItems(1)
    End With
End Function

Private Function PQC_PickFilesMulti(ByVal promptTitle As String, _
                                    ByVal filterDesc As String, _
                                    ByVal filterPattern As String) As Collection
    Dim fd As FileDialog, i As Long
    Dim c As New Collection
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = promptTitle
        .Filters.Clear
        .Filters.Add filterDesc, filterPattern
        .AllowMultiSelect = True
        If .Show = -1 Then
            For i = 1 To .SelectedItems.Count
                c.Add .SelectedItems(i)
            Next i
        End If
    End With
    Set PQC_PickFilesMulti = c   ' may be empty; caller checks Count
End Function

' ---------------------------
' Math (renamed)
' ---------------------------
Private Function PQC_SafePercent(ByVal num As Long, ByVal den As Long) As Double
    If den <= 0 Then
        PQC_SafePercent = 0
    Else
        PQC_SafePercent = num / den
    End If
End Function
